import {
  DndContext,
  DragEndEvent,
  KeyboardSensor,
  PointerSensor,
  closestCenter,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import styled from '@emotion/styled';
import { A } from '@mobily/ts-belt';
import { useCallback, useMemo } from 'react';
import { SubmitHandler, useFieldArray, useForm } from 'react-hook-form';
import { useNodeId, useUpdateNodeInternals } from 'reactflow';
import invariant from 'tiny-invariant';

import { ConnectorID, NodeID } from 'flow-models';

import { useFlowStore } from 'state-flow/context/FlowStoreContext';

import NodeVariableEditableItem from './NodeVariableEditableItem';
import { FieldValues, VariableConfig } from './types';

type Props = {
  nodeId: string;
  isNodeReadOnly: boolean;
  isListSortable?: boolean;
  variables: VariableConfig[];
  onRowHeightChange?: (index: number, height: number) => void;
};

function NodeVariablesEditableList(props: Props) {
  const nodeId = useNodeId() as NodeID;
  const updateNodeInternals = useUpdateNodeInternals();

  const updateVariable = useFlowStore((s) => s.updateVariable);
  const removeVariable = useFlowStore((s) => s.removeVariable);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  const connectorConfigs = useMemo(() => {
    return props.variables.map((variable) => {
      return {
        id: variable.id,
        // NOTE: Map name to value, because the underlining form
        // is generic
        value: variable.name,
        isReadOnly: variable.isReadOnly,
        helperText: variable.helperText,
      };
    });
  }, [props.variables]);

  const { control, handleSubmit } = useForm<FieldValues>({
    values: {
      list: connectorConfigs,
    },
  });

  // NOTE: field will contain all properties of the variable except
  // the "id" is generated by react-hook-form.
  // But in SubmitHandler, the "id" will be the id from the original
  // variable object.
  const { fields, remove, move } = useFieldArray({
    control,
    name: 'list',
  });

  const updateVariables = useCallback<SubmitHandler<FieldValues>>(
    (data) => {
      // NOTE: We don't handle add variable here

      if (connectorConfigs.length === data.list.length) {
        // This is an update

        // NOTE: Elements from the first array, not existing in the
        // second array.
        const updatedVariables = A.difference(
          data.list,
          connectorConfigs,
        ) as typeof connectorConfigs;

        for (const changedVariable of updatedVariables) {
          invariant(
            !changedVariable.isReadOnly,
            'Variable should not be readonly',
          );
          updateVariable(changedVariable.id as ConnectorID, {
            name: changedVariable.value,
          });
        }
      } else {
        // This is a remove

        // NOTE: Elements from the first array, not existing in the
        // second array. Note the order of the arguments is different from
        // above.
        const removedVariables = A.difference(
          connectorConfigs,
          data.list,
        ) as typeof connectorConfigs;

        for (const removedVariable of removedVariables) {
          invariant(
            !removedVariable.isReadOnly,
            'Variable should not be readonly',
          );
          removeVariable(removedVariable.id as ConnectorID);
        }

        // NOTE: Removing a variable will affect edge and handle positions.
        updateNodeInternals(nodeId);
      }
    },
    [
      nodeId,
      connectorConfigs,
      updateVariable,
      removeVariable,
      updateNodeInternals,
    ],
  );

  const onDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;

      if (over == null || active.id === over.id) {
        return;
      }

      const oldIndex = fields.findIndex((f) => f.id === active.id);
      const newIndex = fields.findIndex((f) => f.id === over.id);

      move(oldIndex, newIndex);

      handleSubmit((data) => {
        const list = data.list as typeof connectorConfigs;

        updateVariable(list[oldIndex].id as ConnectorID, {
          // Which index to use for which variable is not important here
          // since data will contain variables in updated order.
          index: oldIndex,
        });
        updateVariable(list[newIndex].id as ConnectorID, {
          index: newIndex,
        });

        // NOTE: Removing a variable will affect edge and handle positions.
        updateNodeInternals(nodeId);
      })();
    },
    [nodeId, fields, handleSubmit, move, updateNodeInternals, updateVariable],
  );

  let editableItemStart = connectorConfigs.findIndex((f) => !f.isReadOnly);
  if (editableItemStart === -1) {
    editableItemStart = connectorConfigs.length;
  }

  return (
    <Container>
      <div>
        {fields.slice(0, editableItemStart).map((field, index) => {
          // TODO: Find a way to avoid duplicating the mapper
          return (
            <NodeVariableEditableItem
              key={field.id}
              isNodeReadOnly={props.isNodeReadOnly}
              isListSortable={false}
              variable={props.variables[index]}
              control={control}
              formField={field}
              index={index}
              onUpdate={() => {
                handleSubmit(updateVariables)();
              }}
              onRemove={() => {
                remove(index);
                handleSubmit(updateVariables)();
              }}
              onHeightChange={(height) => {
                props.onRowHeightChange?.(index, height);
              }}
            />
          );
        })}
      </div>
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={onDragEnd}
      >
        <SortableContext
          disabled={!props.isListSortable}
          items={fields}
          strategy={verticalListSortingStrategy}
        >
          <div>
            {fields.slice(editableItemStart).map((field, index) => {
              index += editableItemStart;
              const variable = props.variables[index];

              // NOTE: This is a workaround for the case when the variable is
              // removed
              // TODO: Find a better way to handle this
              if (variable == null) {
                return null;
              }

              return (
                <NodeVariableEditableItem
                  key={field.id}
                  isNodeReadOnly={props.isNodeReadOnly}
                  isListSortable={!!props.isListSortable}
                  variable={variable}
                  control={control}
                  formField={field}
                  index={index}
                  onUpdate={() => {
                    handleSubmit(updateVariables)();
                  }}
                  onRemove={() => {
                    remove(index);
                    handleSubmit(updateVariables)();
                  }}
                  onHeightChange={(height) => {
                    props.onRowHeightChange?.(index, height);
                  }}
                />
              );
            })}
          </div>
        </SortableContext>
      </DndContext>
    </Container>
  );
}

const Container = styled.div`
  position: relative;
  // padding-left: 10px;
  // padding-right: 10px;
  margin-bottom: 10px;
`;

export default NodeVariablesEditableList;
