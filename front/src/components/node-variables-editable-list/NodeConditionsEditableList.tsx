import styled from '@emotion/styled';
import { A } from '@mobily/ts-belt';
import { useCallback, useMemo } from 'react';
import { useFieldArray, useForm } from 'react-hook-form';
import { useUpdateNodeInternals } from 'reactflow';
import invariant from 'tiny-invariant';

import { ConnectorID } from 'flow-models';

import { useFlowStore } from 'state-flow/context/FlowStoreContext';

import NodeConditionEditableItem from './NodeConditionEditableItem';
import { ConditionConfig, FieldValues } from './types';

type Props = {
  nodeId: string;
  isNodeReadOnly: boolean;
  isListSortable?: boolean;
  conditions: ConditionConfig[];
};

function NodeConditionsEditableList(props: Props) {
  const updateNodeInternals = useUpdateNodeInternals();

  const updateVariable = useFlowStore((s) => s.updateVariable);
  const removeVariable = useFlowStore((s) => s.removeVariable);

  const connectorConfigs = useMemo(() => {
    return props.conditions.map((condition) => {
      return {
        id: condition.id,
        // NOTE: Map expressionString to value, because the underlining form
        // is generic
        value: condition.expressionString,
        isReadOnly: condition.isReadOnly,
      };
    });
  }, [props.conditions]);

  const { control, handleSubmit } = useForm<FieldValues>({
    values: { list: connectorConfigs },
  });

  // NOTE: field will contain all properties of the variable except
  // the "id" is generated by react-hook-form.
  // But in SubmitHandler, the "id" will be the id from the original
  // variable object.
  const { fields, remove } = useFieldArray({
    control,
    name: 'list',
  });

  const updateConditions = useCallback(() => {
    handleSubmit((data) => {
      // NOTE: We don't handle add variable here

      if (connectorConfigs.length === data.list.length) {
        // This is an update

        // NOTE: Elements from the first array, not existing in the
        // second array.
        const updatedVariables = A.difference(
          data.list,
          connectorConfigs,
        ) as typeof connectorConfigs;

        for (const changedVariable of updatedVariables) {
          invariant(
            !changedVariable.isReadOnly,
            'Condition should not be readonly',
          );
          updateVariable(changedVariable.id as ConnectorID, {
            expressionString: changedVariable.value,
          });
        }
      } else {
        // This is a remove

        // NOTE: Elements from the first array, not existing in the
        // second array. Note the order of the arguments is different from
        // above.
        const removedVariables = A.difference(
          connectorConfigs,
          data.list,
        ) as typeof connectorConfigs;

        for (const removedVariable of removedVariables) {
          invariant(
            !removedVariable.isReadOnly,
            'Variable should not be readonly',
          );
          removeVariable(removedVariable.id as ConnectorID);
        }

        // NOTE: Removing a variable will affect edge and handle positions.
        updateNodeInternals(props.nodeId);
      }
    })();
  }, [
    props.nodeId,
    connectorConfigs,
    handleSubmit,
    updateVariable,
    removeVariable,
    updateNodeInternals,
  ]);

  return (
    <Container>
      {fields.map((field, index) => {
        return (
          <NodeConditionEditableItem
            key={field.id}
            isNodeReadOnly={props.isNodeReadOnly}
            isListSortable={!!props.isListSortable}
            condition={props.conditions[index]}
            control={control}
            formField={field}
            index={index}
            onUpdate={updateConditions}
            onRemove={() => {
              remove(index);
              updateConditions();
            }}
          />
        );
      })}
    </Container>
  );
}

const Container = styled.div`
  margin-top: 10px;
  margin-bottom: 10px;
`;

export default NodeConditionsEditableList;
