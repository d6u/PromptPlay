import {
  DndContext,
  DragEndEvent,
  KeyboardSensor,
  PointerSensor,
  closestCenter,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { css } from '@emotion/react';
import { A } from '@mobily/ts-belt';
import {
  ConnectorType,
  NodeKind,
  getNodeDefinitionForNodeTypeName,
  type NodeInputVariable,
  type NodeOutputVariable,
} from 'flow-models';
import { produce } from 'immer';
import { useCallback, useContext, useMemo } from 'react';
import { useFieldArray, useForm } from 'react-hook-form';
import { useUpdateNodeInternals } from 'reactflow';
import RouteFlowContext from 'state-flow/context/FlowRouteContext';
import { useFlowStore } from 'state-flow/flow-store';
import invariant from 'tiny-invariant';
import NodeConfigPaneAddConnectorButton from 'view-left-side-pane/left-side-pane-base-ui/NodeConfigPaneAddConnectorButton';
import { VariableFormValue } from '../types';
import NodeRenamableVariableItem, {
  HandlePosition,
} from './NodeRenamableVariableItem';

type Props = {
  // Depend on rendering location
  isListSortable?: boolean;
  showConnectorHandle?: HandlePosition;
  // Node level
  nodeId: string;
};

function NodeRenamableVariableList(props: Props) {
  const updateNodeInternals = useUpdateNodeInternals();

  const { isCurrentUserOwner } = useContext(RouteFlowContext);
  const isReadOnly = !isCurrentUserOwner;

  const nodeConfig = useFlowStore(
    (s) => s.getFlowContent().nodeConfigs[props.nodeId],
  );

  const nodeDefinition = useMemo(
    () => getNodeDefinitionForNodeTypeName(nodeConfig.type),
    [nodeConfig.type],
  );

  const connectors = useFlowStore((s) => s.getFlowContent().connectors);

  const variables = useMemo((): (NodeOutputVariable | NodeInputVariable)[] => {
    if (nodeConfig.kind === NodeKind.Start) {
      return nodeConfig.outputVariableIds.map(
        (variableId) => connectors[variableId] as NodeOutputVariable,
      );
    }
    return nodeConfig.inputVariableIds.map(
      (variableId) => connectors[variableId] as NodeInputVariable,
    );
  }, [
    connectors,
    nodeConfig.inputVariableIds,
    nodeConfig.kind,
    nodeConfig.outputVariableIds,
  ]);

  const updateVariable = useFlowStore((s) => s.updateConnector);
  const removeVariable = useFlowStore((s) => s.removeVariable);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  const { control, getValues, setValue, handleSubmit } =
    useForm<VariableFormValue>({ values: { list: variables } });

  // NOTE: field will contain all properties of the variable except
  // the "id" is generated by react-hook-form.
  // But in SubmitHandler, the "id" will be the id from the original
  // variable object.
  const { remove, move } = useFieldArray({ control, name: 'list' });

  const submit = useCallback(() => {
    handleSubmit((data) => {
      // NOTE: We don't handle add variable here

      if (variables.length === data.list.length) {
        // This is an update

        // NOTE: Elements from the first array, not existing in the
        // second array.
        const updatedVariables = A.difference(data.list, variables);

        for (const changedVariable of updatedVariables) {
          invariant(!isReadOnly, 'Node should not be readonly');

          const index = data.list.indexOf(changedVariable);
          const prevVariable = variables[index];

          if (prevVariable.name !== changedVariable.name) {
            // If variable name has changed, make sure it's not readonly
            invariant(
              nodeDefinition.fixedIncomingVariables?.[index] == null,
              'Variable should not be readonly',
            );
          }

          updateVariable(changedVariable.id, {
            name: changedVariable.name,
            isGlobal: changedVariable.isGlobal,
            globalVariableId: changedVariable.globalVariableId,
          });
        }
      } else {
        // This is a remove

        // NOTE: Elements from the first array, not existing in the
        // second array. Note the order of the arguments is different from
        // above.
        const removedVariables = A.difference(variables, data.list);

        for (const removedVariable of removedVariables) {
          invariant(!isReadOnly, 'Node should not be readonly');

          const index = variables.indexOf(removedVariable);

          invariant(
            nodeDefinition.fixedIncomingVariables?.[index] == null,
            'Variable should not be readonly',
          );
          removeVariable(removedVariable.id);
        }

        // NOTE: Removing a variable will affect edge and handle positions.
        updateNodeInternals(props.nodeId);
      }
    })();
  }, [
    handleSubmit,
    variables,
    isReadOnly,
    props.nodeId,
    updateVariable,
    nodeDefinition.fixedIncomingVariables,
    updateNodeInternals,
    removeVariable,
  ]);

  const updateNodeConfig = useFlowStore((s) => s.updateNodeConfig);

  const onDragEnd = useCallback(
    (event: DragEndEvent) => {
      const { active, over } = event;

      if (over == null || active.id === over.id) {
        return;
      }

      const variables = getValues().list;

      const oldIndex = variables.findIndex((v) => v.id === active.id);
      const newIndex = variables.findIndex((v) => v.id === over.id);

      move(oldIndex, newIndex);

      if (nodeConfig.kind === NodeKind.Start) {
        updateNodeConfig(props.nodeId, {
          outputVariableIds: produce(nodeConfig.outputVariableIds, (draft) => {
            draft.splice(oldIndex, 1);
            draft.splice(newIndex, 0, active.id as string);
          }),
        });
      } else {
        updateNodeConfig(props.nodeId, {
          inputVariableIds: produce(nodeConfig.inputVariableIds, (draft) => {
            draft.splice(oldIndex, 1);
            draft.splice(newIndex, 0, active.id as string);
          }),
        });
      }
    },
    [
      getValues,
      move,
      nodeConfig.inputVariableIds,
      nodeConfig.kind,
      nodeConfig.outputVariableIds,
      props.nodeId,
      updateNodeConfig,
    ],
  );

  const addVariable = useFlowStore((s) => s.addConnector);

  return (
    <div
      css={css`
        position: relative;
        margin-bottom: 10px;
      `}
    >
      <NodeConfigPaneAddConnectorButton
        label="Variable"
        onClick={() => {
          addVariable(
            props.nodeId,
            nodeConfig.kind === NodeKind.Start
              ? ConnectorType.NodeOutput
              : ConnectorType.NodeInput,
          );
          updateNodeInternals(props.nodeId);
        }}
      />
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={onDragEnd}
      >
        <SortableContext
          disabled={!props.isListSortable}
          items={getValues().list}
          strategy={verticalListSortingStrategy}
        >
          <div>
            {getValues().list.map((variable, index) => {
              const incomingVariableConfig =
                nodeDefinition.fixedIncomingVariables?.[variable.name];

              return (
                <NodeRenamableVariableItem
                  // Must use the variable ID instead of field ID,
                  // because a new field ID is generated
                  // when `props.variableConfigs` updates.
                  // This is to prevent loss of focus when updating variable.
                  key={variable.id}
                  isListSortable={!!props.isListSortable}
                  connectorHandlePosition={props.showConnectorHandle ?? 'none'}
                  nodeId={props.nodeId}
                  isNodeReadOnly={isReadOnly}
                  variable={variable}
                  variableDefinition={{
                    isVariableFixed: incomingVariableConfig != null,
                    helperText: incomingVariableConfig?.helperMessage,
                  }}
                  value={variable}
                  onChange={(value) => {
                    setValue(
                      `list.${index}`,
                      produce(variable, (draft) => {
                        Object.assign(draft, value);
                      }),
                    );
                    submit();
                  }}
                  onRemove={() => {
                    remove(index);
                    submit();
                  }}
                />
              );
            })}
          </div>
        </SortableContext>
      </DndContext>
    </div>
  );
}

export default NodeRenamableVariableList;
